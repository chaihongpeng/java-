servlet stack
servlet技术栈主要使用的是BIO,一个servlet接受所有的请求
分配给不同的线程去处理请求
JDBC,JPA,NSQL的数据库也是阻塞式，接受请求后要等处理完成之后进行数据返回，这些请求都会在一个独立的线程里面

命令式编程，所有操作都在一个线程里
一个流式编程

reactive stack

ServerSocket是BIO

Netty或者NIO包实现NIO
NIO和BIO的线程池，作用是和客户端建立连接

浏览器支持的异步回调协议有ws

1》建立完连接后，NIO或者BIO都会在new出一个Thread,这条Thread才会真正去干活，开一个线程至少会有1M的内存开销
线程数超过上限就会拒绝连接

2》之后引入了队列的概念,任务放在队列中，服务器专门去消费消息，优点用户可以非常快速的完成请求，缺点是用户无法拿到响应的数据，浏览器想要拿到结果只能轮询或长轮询
	轮询和长轮询的区别：长轮询是一个请求不完事就持续等待拿到数据，http默认90秒连接，过期后需要续租

3》基于Netty的Servlet3.1实现的响应式编程框架，websocket
	计算业务比较高的业务，需要少开线程，保证cpu的效率
	io等阻塞请求，需要多开线程线程压榨cpu
	
Flux底层是由流组成的
响应式数据库





应用层：
	考虑的是数据如何从一个应用发送到另一个应用，如浏览器到服务器;
	他不关心机器的概念;
	也不关心网络细节;

传输层：
	数据拆分和重组
	纠错，传输过程中出现问题纠正，如丢包重发
	管理连接；处理数据的频繁交换
	流量控制：控制传输数据的传输速率
	端口寻址：标明与传输实体的端口
网络层:
	把封包从一个ip发送到另一ip
	提供路由和寻址的能力
数据链路层：
	确保两个临近设备的数据传输，并隐藏了底层实现，他描述浏览器到网卡，网卡到路由器，路由器本地运营商服务器
	帧同步
	数据纠错
物理层：
	封装具体的设备，如光纤，蓝牙等
	负责0-1电信号的传输



互联网协议群
-----删除了会话层和表现层的概念，因为用户不一定需要会话，也不一定需要表现层进行数据转化
	TCP、IP协议群
		报文拆分：
			解决大文件传输不稳定
			拆分的包可以由多个路径分别传输，增加复用性
		增加协议头
			头部的描述字段
			消息体
		数据在相邻设备间传输
		路由和寻址
			路由算法
		数据重组
			分包的重组
			
	传输层TCP协议UDP协议TLS/SSL、SCTP等
	网络层IPV4、IPV6、ICMP协议、IPSec安全协议
	
什么是连接
什么是双工
	单工只能单项发送
	半双工，某一个时刻，只允许数据在一个方向上传输
	全双工，任何时刻都能双向发送数据(所以双工至少需要两条线路)
什么是无损传输
	
	
	
TCP的三次握手
	发出数据键syn
	返回数据较ack
		客户端发送一个syn请求传输数据
		服务端准备好后返回一个ack，表示可以进行数据传输，服务端在发一个syn，表示想要进行数据传输，ack和syn是在一个包里被发送
		客户端准备就绪，发送ack给服务端

断开连接四次挥手
	客户端发送FIN,表示要关闭连接
	服务端发送ACK,服务端最后去处理还未处理完的数据，如未发送完的数据，资源关闭
	服务端处理完所有事情在发送FIN，表示可以断开连接
	客户端处理完手里最后的工作，在回应ACK，告诉服务端客户端的事情也做完了，可以断开了
	
传输数据
	TCP将数据拆分成小的数据块，增加TCP头，接受数据时进行重组
	引用层数据拆分成小块TCP段，包拆的太小消耗cpu资源，拆的太大不利于传输
数据传输数据的保证
	数据到达后是乱序的，需要排序
		方案一，序号标记
		Seq发送序号
		ACK接受序号，一个端的发送序号就是另一端的接受序号



IP
	任由数据在网络中传输，不保证传输的可靠性
		IP协议可能出现的问题
		封包损坏、丢包、重发、乱序
		
		网络层三大问题
			延迟，
			吞吐量，
			丢包率：丢包会造成延迟也会升高，因为可能要重新发送丢掉的包
		
	分片
		数据切成片
	增加协议头
		协议头长度
		服务类型
		total length报文长度
		报文id(用于排序)
		
		Protocal上层协议类型
		checksum校验数据是否损坏
		源IP
		目的IP
	调用局域网，寻址，路由
	
	寻址IPV4是一个32位，顶网找逐级找到子网在找到设备
		顶层网路有127、103
		
	
	操作系统接到请求会放入pending Queue中
	直到某一个派发线程触发accept()系统调用
	在内核空间形成一个socket文件
	socket文件形成一个资源句柄fd
	最后派发线程发送给工作线程，由工作线程去处理fd
	最后工作线程就可以直接把返回值写入到fd
	
	
	为什么区分派发线程和工作线程，因为accept方法本身消耗时间，如果用accpet去处理数据，请求就会更长时间的去排队，所以转么分出派发线程区快速处理pending queue中的内容
	
	ServerSocket.accept获取一个socket
	socket可以获取输入和输出流，处理完后关闭
	
	
	DateInputStream可以读取Char、Float等类型
	
	
	NIO的核心概念
	nio将数据存储到buffer当中，形成cannel，在数据完全创建后生成工作线程才会从cannel中读取数据，这样就减少了工作线程的阻塞时间
	ssc = ServerSocketChannel.open()
	ssc.bind(new InetSocketAddress(port))
	ssc.configureBlocking(false)
	
	for(;;)性能高于while(true),可以省略一次判断
	
	
	HTTP协议
	HTTP/1.1 200 OK   ---200状态码,OK状态描述
	
	URL https://www.baidu.com:80/books?id=100#Good  ---https scheme描述协议; www.baidu.com host主机;8080 port端口;books path资源目录;id=100 query查询条件 #Good fragment二级分类，通常给前端用的
	
	DNS域名解析系统，因为互联网传输数据IP协议要求必须知道ip地址,浏览器询问DNS来寻找www.baidu.com的ip地址
	
	
	
	
	
	

















