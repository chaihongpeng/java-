文件系统的io
内存与io
网络与io

kernel操作系统内核，一个程序
app用户程序

内存，cpu，io设备：磁盘，网卡，其他Io设备

程序一般无法直接访问硬件，需要调用系统

系统内核既管内存分配又管磁盘io
内核中VFS虚拟文件系统，内存中会先生成一个VFS，一个目录树，树上的节点可以映射不同物理位置，可以是硬盘的节点，网络的节点

window就是物理的文件系统，我们看到的c盘就问硬盘上的c盘，d盘就是硬盘的d盘

linux的虚拟文件系统目的是为了解耦，实现通过vfs中间件就可以访问不同的硬件设备。

inode抽象想象一个id,每一个文件都有一个inode号。
读文件过程，范文内核，在树当中打开那个文件，inode号被加载，元数据被加载，内核将数据读到内存，开辟一个pagecache叶缓存，默认是4k

知识点：多个app打开同一个文件时，pagecache是共享的，app访问文件系统时，文件系统发现已经加载过文件，就会直接返回已存在的pagecache。

		pagecache是内存对数据的缓存
		dirty脏数据，程序对数据进行了修改，程序就会被标记为脏，flush将数据书写到磁盘当中去
		
		脏标识是内核对所有app统一的管理，并不是单独某一个文件的
		
		flush可以程序调用直接刷新，也可以交由操作系统判断数据的刷盘
		直接刷可以保证数据的准确，交给内核就有可能会丢数据
		
		和java中一样，多个程序打开同一个文件，内核就会把pagecache放到内存当中，谁都可以读谁的可以写，之后决定加锁不加锁
		有点像java中的迭代器模式。
		FD文件描述符：最终交给程序，fd会有一个指针seek。app在读取文件的不同位置时，各自有各自的seek指针
		如果在没有修改同一个位置的数据时，是不需要加锁的，当修改到同一个数据时，就会加锁
		
		
		
1.虚拟文件系统，他是一个树状，会有一个根目录/
2.df命令，可以看到虚拟的目录树结构


讲解：
	第一个知识点，虚拟目录树
	
	
	假设有一个硬盘，规划了三个分区
	有1分区，2分区，3分区
	swap的交换分区
	root的根分区/
	
	看似在一起的文件夹，其实是可能来自于不同分区的
	在使用df命令时，可以看到
	根分区来源于3分区,
	但是紧接着下面会有boot就来自于1分区
	这代表在根分目录下所有数据都来源于3分区，但是boot来源于1分区，df命令下面是优先级高于上面
	
	计算机通电后，内核进入内存，内核初始化文件系统，这是他是一个空的只有一个根目录，他把根映射到3分区，三分区会有很多的目录，boot目录，dev目录，etc目录，三分区是有这些
	目录的，只不过引导的顺序是第一件事情是先加载的三分区，在把boot挂载到1分区
	
	kernel在1分区，kernel通过引导程序进入到内存，接管控制权，
	
	mount是linux的挂载命令
	umount是卸载命令
	
	第二个知识点，文件类型，前面还有一句话，冯诺依曼：计算机组成，计算器,控制器(cpu),主存储器(内存)，输入输出设备(io设备)
				一切皆文件的抽象，打印机，摄像头都可以是文件
				
				
				linux的文件类型其实很多
					-代表普通文件
					d目录文件的意思
					b块设备，可以自由读的就是块设备，如硬盘
					l连接的类型，有点类似于快捷方式
					c字符设备，不可已有读以前以后，如键盘
					s开头的socket
					p管道pipeline
					eventpoll表示内核提供的epoll内存区域





system.call系统调用
int 0x80


socket

lsof显示进程打开了哪些文件
lsof -p [进程]

任何程序都有0 1 2
0标准输入
1标准输出
2报错输出

文件描述符，它会存储文件的位置指针，偏移，inode号
不同进程的打开一个文件，进程的偏移量offset指针各自不同0t16 0t0
















