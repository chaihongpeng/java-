# 操作系统层次

 ```mermaid
 graph LR
 user[用户]--1-->application[应用程序]-->os[操作系统]-->hardware[硬件]
 user--2-->os
 
 ```
1. 用户可以通过应用程序和操作系统打交道
2. 用户也可以直接与操作系统打交道

#### 操作系统提供的功能

- 处理机管理
- 文件管理
- 存储器管理/内存管理

- 设备管理

# 操作系统提供的接口

- 命令接口: 允许用户直接使用
  - 联机命令接口
    - 接口特点: 用户说一句, 系统做一句
    - =交互命令接口
  - 脱机命令接口
    - 接口特点: 用户说一堆, 系统做一堆
    - =批处理命令接口, 对应windows中的`.bat`文件
- 程序接口: 允许用户通过程序间接使用
  - 程序员通过调用`.dll`文件, 实现用户程序间的使用
  - =系统调用
- GUI: 图形用户界面

# 操作系统的特征

- 并发
  - 两个或多个事件在同一个时间间隔内发生
  - 并行是指两个或者多个事件在同一时刻发生
- 共享
  - 系统中的资源可以供多个并发执行的进程共同使用
  - 互斥共享
    - 一个时间段内只允许一个进程进行访问
    - 例: 摄像头在一个时间内只允许一个进程进行使用
  - 同时共享
    - 一个时间段内允许多个进程对其进行访问
    - 两个进程交替访问硬盘, 扬声器同时播放游戏和音乐的声音
- 虚拟
  - 把物理上的实体变为若干个逻辑上的对应物
  - 空分复用技术
  - 时分复用技术
  - 没有并发,一段时间内如果只需运行一个程序, 虚拟性也就没有存在的意义了

- 异步
  - 多道程序环境下, 允许程序并发执行, 但是由于资源限制, 进程执行不是一贯到底, 而是走走停停, 已不可预知的速度向前推进, 这就是进程的异步性

# 运行机制和体系结构

- 什么是指令
  - C语言,JAVA语言最终都会翻译为等价的机器指令, 一条高级语言的代码可能会对应多条指令
  - 机器语言指令使用二进制表示的
  - 指令就是处理器(CPU)能识别和执行的最基本命令

# 运行机制

- 两种指令
  - 特权指令: 如内存清零指令
    - 特权指令不允许普通的用户程序使用
  - 非特权指令: 普通加减乘除运算指令
- 处理器状态
  - CPU在执行指令前会进行判断当前是否允许执行特权指令
  - 这两种状态是用寄存器(PSW)中的某个标识位当做当前处理器处于什么状态
  - 用户态(目态): 只能执行非特权指令
  - 核心态(管态): 特权指令和非特权指令都可以执行
- 程序分类
  - 内核程序: 操作系统的核心内容, 他是系统资源的管理者, 既可以执行特权指令也可以执行非特权指令, 运行在核心态
  - 应用程序: 为了保证系统运行的安全, 只能执行非特权指令, 运行在用户态
  - 操作系统哪些功能应该由所谓的内核程序来实现呢?

# 操作系统内核

- 操作系统分层
  - 非核心功能
    - 进程管理
    - 存储器管理
    - 设备管理等功能

  - 内核
    - 时钟管理
    - 中断处理
    - 原语(设备驱动,CPU切换等)
      - 一种特殊程序
      - 操作系统的最底层, 最接近硬件的部分
      - 这种程序的运行具有原子性,一气呵成不可以被中断
      - 运行时间较短,调用频繁

# 操作系统体系结构

- 大内核
  - 包含非核心功能的操作系统
  - 将系统的主要功能都作为系统内核, 运行在核心态
  - 优点高性能
  - 缺点: 内核代码庞大, 结构混乱, 难以维护
- 微内核: 只包含最基本必不可少功能结构
  - 只把最近本的功能保留在系统内核当中
  - 优点内核功能少, 结构清晰, 方便维护
  - 缺点: 需要频繁的在内核态和用户态之间切换, 性能低

## 中断和异常

# 中断概念

- 中断机制是为了实现多道程序并发执行而引入的一种技术
- 中断发生后, CPU会立即进入核心态
- 当中断发生后, 当前运行的进程会暂停运行, 并由操作系统的内核对中断进行处理
- 对于不同的中断信号, 操作系统会进行不同的处理
- 用户太到核心态的切换是通过中断来实现的, 并且中断是唯一的途径
- 核心态到用户态切换是通过一个特权指令, 将程序状态字(PSW)的标志位设置为用户态

# 中断的分类

## 分类方式一

- 内中断(也称为异常,例外,缺陷)
  信号来源于CPU内部, 与当前执行的指令有关
  - 自愿中断
    - 指令中断: 例:系统调用
  - 强迫中断
    - 硬件故障: 例:如缺页中断
    - 软件中断: 例:如整除0
- 外中断(简称为中断,狭义的中断)
  信号来源于CPU外部,与当前指令的执行无关系
  - 外设请求: IO操作完成后,IO设备会向CPU发送一个中断信号
  - 人工干预: 用户强行终止一个进程



## 分类方式二

- 内中断(内部异常)
  - 陷入,陷阱(trap): 有意而为之的异常, 如系统调用
  - 故障(fault): 由错误条件引起, 可能被故障处理程序修复, 如缺页
  - 终止(abort): 不可恢复的致命错误造成的结果
- 外中断
  - IO中断
  - 人工干预

# 中断的处理过程

1. CPU在用户态下执行应用程序的指令
   1. 执行完每个指令之后, CPU都会例行检查当前是否有外部中断信号需要处理
      1. 如果没有外部中断信号,继续执行下一条用户程序的指令
   2. 如果在指令执行后有一条中断信号需要处理
      1. 操作系统介入处理中断信号
      2. 用户程序需要暂停运行
      3. 保护被中断用户进程CPU环境(如程序状态子PSW,程序计数器,各种通用寄存器), 就是把程序运行的中间结果暂时保存下来, 以便之后可以恢复继续执行
      4. 转入相应的中断处理程序, 中断处理程序属于系统内核的, 运行在核心态
      5. 中断处理程序执行结束之后需要恢复原进程的CPU环境并退出中断, 返回原进程继续往下执行

# 系统调用

- 系统调用的本质目的
  - 应用程序共享资源由操作系统统一掌管
  - 凡是与资源有关的请求(如分配存储,IO操作,文件管理等),都必须通过系统调用的方式向操作系统提出服务请求,由系统代为完成
  - 可以保证系统的稳定性和安全性, 防止用户进行非法操作

- 系统调用的分类
  - 设备管理: 完成设备的 请求/释放/启动 等功能
  - 文件管理: 完成 读/写/创建/删除 等功能
  - 进程管理: 完成进程 创建/撤销/阻塞/唤醒 等功能
  - 进程通信: 完成进程间的 消息传递/信号传递 等功能
  - 内存管理: 完成内存 分配/回收 等功能

- 系统调用和库函数的区别
  - 上层语言提供的函数, 有时会将系统函数封装, 以隐藏系统调用的细节, 是上层系统调用更方便
  - 库函数也可能不涉及系统调用

# 进程

# 进程组成

- 进程实体(进程映像)
  - 程序段
    - 存放程序代码本身
  - 数据段
    - 处理数据(如变量)放在数据段
  - PCB: 
    - 用来描述进程的各种信息(如程序代码的存放位置)
- 进程定义: 进程是进程实体的运行过程, 是系统进行资源分配和调度的一个独立单位
- 进程实体是一个静态概念, 表示数据本身. 而进程强调动态, 表示数据运行的过程

- PCB
  - 进程描述信息
    - 进程标识符PID
    - 用户标识符UID
  - 进程控制和管理信息
    - 进程状态
    - 进程优先级
  - 资源分配清单
    - 程序段指针
    - 数据段指针
    - 键盘
    - 鼠标
  - 处理机相关信息
    - 各种寄存器值: 当前进程切换需要把进程当前的运行情况记录下来保存在PCB中, 如程序计数器的表示了当前程序执行到那一句了
- PCB
  - 进程标识符
  - 处理机状态
  - 进程调度信息
  - 进程控制信息

# 进程组织

- 进程的组织方式
  - 链接方式
    - 操作系统按照进程的状态吧PCB分为多个队列
    - 操作系统持有指向个个队列的指针
  - 索引方式
    - 根据进程的状态不同, 建立几张索引表 	
    - 操作系统持有指向个个索引的指针

# 进程状态与转换

- 三种基本状态
  - 运行态: 占用CPU资源, 并在CPU上运行, 单核CPU每个时刻最多只能有一个进程处于运行态
  - 就绪态: 已具备运行条件, 但是由于没有空闲CPU, 暂时不能运行
  - 阻塞态: 因等待某一事件暂时不能运行, 进程等待分配打印机 等待读取磁盘操作的结果,为了提高CPU的利用率, 需要先将其他进程需要的资源分配到位,才能得到CPU服务
- 另外两种状态
  - 创建态:进程正在被创建, 操作系统为进程分配资源, 初始化PCB
  - 终止态: 进程正在从系统中撤销, 系统将回收进程拥有的资源,撤销PCB

# 进程控制

进程控制相关的原语

原语:一种特殊的程序,它的执行具有原子性,这段程序运行必须一气呵成,不可中断

PCB中的变量state表示进程当前所处的状态, 1表示就绪态, 2表示阻塞态

如果一个进程的处于就绪态, 进程的PCB挂载在就绪队列指针

进程处于阻塞态, 进程就挂载在阻塞队列里

处于阻塞队列里的进程肯定是在等待某种事情的发生

假设进程二等待的事件发生,则操作系统中,负责进程控制的内核程序至少做了两件事

1. 将PCB2的state设置为1
2. 将PCB2从阻塞队列放到就绪队列

以上例子中, 如果步骤1执行完后,又发生了其他中断而打断了步骤2, 就会造成关键数据结构不统一的情况

原语的执行是具有原子性, 即执行过程只能一气呵成, 期间不允许被中断. 可以用"关中断"和"开中断"这两个特权指令实现原子性

特权指令只能有由内核使用, 不能给用户使用

CPU会在每次执行完指令之都会例行检查是否有中断信号需要处理, 如果发现有中断信号, CPU就会暂停执行当前程序,转而执行一个处理中断的程序, 等中断处理完成之后才会回到原来的程序继续往下执行

CPU执行了关中断指令后, 就不在例行检查中断信号, 直到执行开中断指令之后才会恢复检查

在执行完开中断指令之后, 才会继续执行理性检查中断信号

利用开中断和关中断指令实现了指令不可被中断的原子性



# 进程原语

## 进程的创建

创建原语

- 申请一个空白的`PCB`
- 为进程分配它所需要的资源
  - 比如内存空间
- 初始化`PCB`
  - 分配`PID`
  - 设置`UID`
  - ...
- 将PCB插入到就绪队列
  - 创建原语会让一个进程从`创建态-->就绪态`

引起进程创建的事件

- 用户登录
- 作业调度
- 提供服务
- 应用请求

## 进程的终止

撤销原语

`就绪态/阻塞态/运行态-->终止态-->无`

- 从`PCB`集合中找到终止进程的`PCB`
- 若进程正在运行, 立即剥夺`CPU`的使用权, 将`CPU`分配给其他进程
- 终止所有子进程
  - 进程间的关系是树状结构
- 将该进程拥有的所有资源归还给父进程或操作系统
- 删除`PCB`

引起进程终止的事件

- 正常结束: 进程自己请求终止
- 异常结束: 程序异常等
- 外界干预: 用户选择杀掉进程

## 进程的阻塞和唤醒

### 进程的阻塞

阻塞原语

- 找到要阻塞进程对应的`PCB`
- 保护进程运行现场, 将`PCB`状态设置为`阻塞状态`, 暂时停止进程运行
- 将`PCB`插入相应的等待队列

引起进程阻塞的事件

### 进程的唤醒

唤醒原语

- 在事件等待队列中找到`PCB`
- 将`PCB`从等待队列中移除, 设置进程为就绪态
- 将`PCB`插入到就绪队列, 等待被调度

引起进程唤唤醒的事件

- 等待的事件的发生

## 进程的切换

切换原语
`运行态-->就绪态` `就绪态-->运行态`

- 将运行环境信息存入`PCB`
- `PCB`移入相应队列
- 选择另一个进程执行, 并更新`PCB`
- 根据`PCB`恢复新进程所需要的运行环境

## 程序的运行

`CPU`在执行指令的时候, 会进行一系列的运算, `CPU`中会设置很多的`寄存器`, 用来存放程序运行过程中所需要的某些数据



`PSW` 程序状态寄存器, `CPU`是内核态还是用户态, `PSW`除了`CPU`状态信息还会保存别的信息, 详细看计算机组成原理

`PC`程序计数器寄存器,存放下一条指令的地址

`IR`指令寄存器, 存放当前`CPU`正在执行的指令

`通用寄存器`其他一些必要的信息



在进程切换时,先在`PCB`中保存这个进程的运行环境(保存一些必要的寄存器信息), 当原来的进程再次投入运行时, 可以通过`PCB`恢复它的运行环境

## 总结

无论哪一个进程控制原语, 要做的事情无非三件

- 更新`PCB`中的信息
- 将`PCB`插入到合适的队列
- 分配/回收资源

# 进程通讯

进程通讯`Inter-Proccess Communication` `IPC` 是指两个进程之间产生数据交互
