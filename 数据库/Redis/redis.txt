磁盘：
	寻址ms，带宽G/m
内存：
	寻址ns,带宽

I/O Buffer
磁盘一扇区512byte,索引就是4k，一次无论读多少默认最小读取4k

数据可以存在文件里
文件越大，读取速度越慢
datapage概念，大小是4k

关系型数据库即使为指定值的字段也会用空值填充，目的是为了下次修改时不需移动数据

mysql会在内存中存放一个B+树
b+树的树叶是4kdatapage,B+树的树干放在内存中

数据库的表如果数据很大，性能一定会降低？
如果表有索引，增删改会变慢
一个查询速度依然很快
并发查询时受磁盘带宽影响，后面的查询会等待前面的查询完毕后才可以执行


redis中所有的类型值得是值，键都是k

String 字符操作，数值类型操作,bitmaps 
Hash
List 
Set 
ZSet	


epoll命令的介绍
计算机有kernel内核
客户端连接client
一个连接就有一个fd文件描述符
bio线程就是阻塞的
nio非阻塞io:可以通过轮询处理，同步非阻塞，轮询调用次数成本大，1000个fd就要调用1000次轮询
内核新增了select系统调用：内核一次监听多个文件描述符，在调用read，目的是减少系统调用，select又叫做多路复用

mmap映射，用户态和内核态之间的共享空间
零拷贝：sendfile(out,in)	read(fd) write(fd)

epoll_create会准备一个df，通过mmap准备一个共享空间
epoll_wait等待事件，然后需要程序单独调用read方法

redis是单进程单实例
并发来时，多个客户端client会和kernel进行连接，redis和进程之间使用的是epoll,redis对所有的数据都是单进程处理
只有windows有aio,linux没有aio

JVM中，一个线程的成本，线程栈的大小是1M,线程多了调度成本高，内存成本高


Redis的类型

通过keys *XX*
mget组合查找

string类型：可以是数值，字符串，bitmap
	meset 批量操作，原子性操作，一个失败其余都失败
	二进制安全，redis中的所有字符都是以二进制编码的形式储存
	字符串：set <key> <value> <nx只能创建|xx只能更新>
			append 追加
			getrange 截取
			setrange 截取替换
			strlen 取长度
			getset 获取并设置(远程调用节省一次数据包发送)
			点赞，评论，访问数完全可以用redis内存操作代替
	字节：setbit
	
hash类型：
	

zset类型：首先它是set集合


redis作为数据库和缓存的区别
	缓存数据不重要
	缓存不是全量数据
	缓存应该随着访问而变化
	
	如果redis只是作为缓存，redis里的数据怎么随着业务变化而变化，因为内存大小也存在瓶颈
	key的有效期问题：
		业务逻辑推动
		内存有限，随着访问变化而淘汰冷数据
	
	redis内存，可以通过maxmemory <byte>区控制内存大小
	内存满了处理配置
		maxmemory-policy 
			noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）（redis如果作为一个数据库区使用，需此设置防止数据丢失）
			allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
			volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。（如果有序有指定过期时间，则使用该配置）
			allkeys-random: 回收随机的键使得新添加的数据有空间存放。
			volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
			volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。

	redis没有延续过期时间的概念，需要程序员自己去补全业务逻辑
	
	redis的淘汰过期被动和主动：
		被动：访问时判定
		主动：周期轮询判定
		最终目的：稍微牺牲内存，但是保证redis的性能为王
		
		
redis的持久化
	RDB:快照，它具有时点性，它会延续几十秒
		当你的程序有了数据之后，fork一个子进程，子进程与父进程的数据是是隔离的，写实复制是内核的一种机制，每一笔修改会触发内核级别的写时复制copyonwrite
		快照可以手动触发，阻塞触发save或非阻塞bqsave
		也可以在配置文件中进行save配置：save <每次触发时间间隔> <操作数触发条数>
		save只有在系统管理维护的时候才会使用save进行持久化
		弊端：
			丢失数据相对较多
			RDB存储文件不支持拉链，每次备份会丢失之前的备份，所以需要手动copy复制
		优点：
			类似java的序列化，恢复速度相对较快
	AOF:日志追加


linux的管道：
	1.管道，衔接前一个命令的输出作为后一个命令的输入
	2.管道会触发一个子进程
	
目的，使用linxu时候会有一个父子进程的概念。

父进程数据子进程是否可以看得到？
常规中，进程是要进行数据隔离的
进阶只是，父进程可以让子进程看到数据
linux中子进程的数据修改不会破坏子进程，子进程数据修改也不会破坏父进程
copy on write:写时复制，创建子进程并不发生赋值，只有在写操作时复制























